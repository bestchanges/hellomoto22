import datetime
import json
import logging
import threading
from threading import Thread
from urllib.request import Request, urlopen
import time

import sys

from bestminer.models import Currency, Rig
from exchange.exchange import PoloniexExchange, BitfinexExchange

logger = logging.getLogger(__name__)


def calc_mining_profit(currency, user_hashrate, period=86400):
    '''
    * считаем сколько монет за определенное время можем получить на данном оборудовании
    N = (t*R*H)/(D*2^32)
    где:
    N - доход в монетах
    t - период майнинга в секундах (например, сутки = 86400)
    R - награда за блок в монетах
    H - хэшрейт в секунду (например, 1ГХш = 1000000000)
    D - сложность

    доход в сутки = ( мощность фермы / мощность сети ) Х кол-во монет в сутки
    кол-во монет в сутки  = ( 86400 Х монет за блок ) / время нахождения блока

    :param coin_data: the data generated by for_currency("ETH")
    :param hashrate:
    :param period:
    :return: amount of currency earned during period
    '''
    if not currency.nethash:
        raise Exception("currency {} has no nethash".format(currency))
    if not currency.block_time:
        raise Exception("currency {} has no block_time".format(currency))
    net_hash = currency.nethash
    block_time = float(currency.block_time)
    # некорректно считает например для FTC difficulty == 56
    # block_time = coin_data["difficulty"] / net_hash
    block_reward = float(currency.block_reward)
    user_ratio = user_hashrate / float(net_hash)
    net_reward = period / block_time * block_reward
    user_reward = net_reward * user_ratio
    return user_reward


class ProfitManager():
    def __init__(self, sleep_time=300, save_wtm_to_file=None):
        self.sleep_time = sleep_time
        self.save_wtm_to_file = save_wtm_to_file

    def start(self):
        self.thread = threading.Thread(target=self.run, name='Profit manager')
        self.thread.start()

    def evaluate_rig(self, rig):
        exchanges = [
            BitfinexExchange(),
            PoloniexExchange(),
        ]

        best_algos = {}
        for algo, hashrate_data in rig.target_hashrate.items():
            algo_profit_btc = 0
            bests = []
            for algorithm in algo.split('+'):
                hashrate_value = hashrate_data[algorithm]
                logger.info("{} {} {}".format(algo, algorithm, hashrate_value))
                currencies = Currency.objects(algo=algorithm)
                logger.info(currencies)
                max_profit_currency = {'a': algorithm, 'max': 0, 'c': None, 'e': None}
                for currency in currencies:
                    try:
                        profit = calc_mining_profit(currency, hashrate_value)
                        # try to convert on exchanges
                        profit_btc = 0
                        exchange_code = None
                        best_exchange = {'e': None, 'rate': 0}
                        for exchange in exchanges:
                            try:
                                rate = exchange.exchange_rate(currency.code, 'BTC')
                                if rate:
                                    if rate > best_exchange['rate']:
                                        best_exchange = {'e': exchange.code, 'rate': rate}
                            except Exception as e:
                                logger.warning("error converting {} in {}: {}".format(currency, exchange, e))
                                continue
                        profit_btc = best_exchange['rate'] * profit
                        if profit_btc > max_profit_currency['max']:
                            max_profit_currency = {'a': algorithm, 'c': currency.code, 'max': profit_btc,
                                                   'e': best_exchange}
                        logger.info("{} = {} ({} BTC)".format(currency.code, profit, profit_btc))
                    except Exception as e:
                        logger.error(e)
                        raise e
                bests.append(max_profit_currency)
                logger.warning(
                    "Algorithm {} Best currency {} = {} BTC (at {})".format(algorithm, max_profit_currency['c'],
                                                                            max_profit_currency['max'],
                                                                            max_profit_currency['e']))
                algo_profit_btc = algo_profit_btc + max_profit_currency['max']
            logger.error("Algo {} = {} BTC".format(algo, algo_profit_btc))
            best_algos[algo] = {'profit': algo_profit_btc, 'c': bests}
        print(json.dumps(best_algos, indent=2, sort_keys=True))

    def load_data_from_whattomine(self):
        logger.info("Loading currencies data from WhatToMine")
        try:
            q = Request('http://whattomine.com/coins.json')
            q.add_header('User-agent',
                         'Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5')
            a = urlopen(q)
            response = a.read().decode('utf-8')
            result = json.loads(response)
            return result
        except Exception as e:
            logging.error("Error loading currencies: {} ".format(e))

    def update_currency_data_from_whattomine(self, wtm):
        '''
        :param wtm: What To Mine JSON decoded
        :return:
        '''
        logger.info("Update currency data {} items.".format(len(wtm['coins'].items())))
        now = datetime.datetime.now()
        for currency, data in wtm['coins'].items():
            Currency.objects(
                code=data['tag'],
            ).update_one(
                algo=data["algorithm"],
                block_reward=data["block_reward"],
                block_time=data["block_time"],
                difficulty=data["difficulty"],
                nethash=data["nethash"],
                updated_at=now,
                upsert=True
            )

    def run(self):
        # False = disable periodical load
        while True:
            logger.info("Load data from what to mine")
            try:
                wtm_data = self.load_data_from_whattomine()
            except:
                e = sys.exc_info()[0]
                logger.error("Exception load WTM data: {}".format(e))
                continue
            if self.save_wtm_to_file and wtm_data:
                fout = open(self.save_wtm_to_file, 'w')
                json.dump(wtm_data, fout, indent=2)
                fout.close()
            try:
                if wtm_data:
                    self.update_currency_data_from_whattomine(wtm_data)
            except:
                e = sys.exc_info()[0]
                logger.error("Exception update_currency_data_from_whattomine: {}".format(e))
            logger.info("Load data from what to mine after {} ".format(self.sleep_time))
            time.sleep(self.sleep_time)


def main():
    logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO)
    # data = pm.load_data_from_whattomine()
    data = json.load(open('coins.json'))
    profit_manager = ProfitManager()
    profit_manager.update_currency_data_from_whattomine(data)
    rig = Rig.objects.get(worker="worker002")
    profit_manager.evaluate_rig(rig)


if __name__ == '__main__':
    main()
