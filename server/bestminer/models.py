import datetime
from statistics import median

import mongoengine
from mongoengine import StringField, Document, BooleanField, DateTimeField, DecimalField, FloatField, URLField, \
    ReferenceField, ListField, DictField, UUIDField, IntField, EmbeddedDocument, EmbeddedDocumentField, \
    queryset_manager, LongField

# we do net restric algorithms anymore
# ALGORITHMS = (
#    'Ethash', 'Equihash', 'SHA256', 'Scrypt', 'Blake', 'X11', 'Pascal', 'LBRY', 'X11Gost', 'CryptoNight', 'NeoScrypt')

# TODO: no way. Switch to PoolManager
POOLS_FAMILY = ('ethermine', 'flypool', 'openethpool', 'coinmine', 'suprnova')
SUPPORTED_OS = ('Windows', 'Linux')
OS_TYPE = (('Windows', 'Windows'), ('Linux', 'Linux'))

GPU_RX_470 = 'amd_rx_470'  # possible template is 'amd_rx_470_4g_samsung'
GPU_RX = 'amd_rx'
PU_TYPE = (('amd', 'amd'), ('nvidia', 'nvidia'))


# that's cause circular dependency
# MANAGERS = (
#     (rig_manager.AUTOPROFIT, rig_manager.AUTOPROFIT)
#     ,(rig_manager.BENCHMARK, rig_manager.BENCHMARK)
#     ,(rig_manager.MANUAL, rig_manager.MANUAL)
# )


class Currency(Document):
    code = StringField(max_length=20, unique=True)
    difficulty = FloatField()
    algo = StringField(max_length=50)  # actually should be named 'algorithm' TODO: rename
    block_time = FloatField()  # seconds
    block_reward = FloatField()
    nethash = LongField()
    updated_at = DateTimeField()
    listed_in = ListField(StringField(), default=[]) # exchange_code from exchanges
    exchange_rates_btc = DictField(default={}) # exchange_code : data {'volume_24h': xx, 'rate': xx, 'updated': ... }

    def get_median_btc_rate(self):
        rates = []
        # TODO: check if rate too old
        for exchange_rate_btc in self.exchange_rates_btc.values():
            rates.append(exchange_rate_btc['rate'])
        if not rates:
            return None
        return median(rates)

    def __unicode__(self):
        return self.code

    def calc_mining_profit(self, user_hashrate, period=86400):
        '''
        * считаем сколько монет за определенное время можем получить на данном оборудовании
        N = (t*R*H)/(D*2^32)
        где:
        N - доход в монетах
        t - период майнинга в секундах (например, сутки = 86400)
        R - награда за блок в монетах
        H - хэшрейт в секунду (например, 1ГХш = 1000000000)
        D - сложность

        доход в сутки = ( мощность фермы / мощность сети ) Х кол-во монет в сутки
        кол-во монет в сутки  = ( 86400 Х монет за блок ) / время нахождения блока

        :param coin_data: the data generated by for_currency("ETH")
        :param hashrate:
        :param period:
        :return: amount of currency earned during period
        '''
        if not self.nethash:
            raise Exception("currency {} has no nethash".format(self))
        if not self.block_time:
            raise Exception("currency {} has no block_time".format(self))
        net_hash = self.nethash
        block_time = float(self.block_time)
        # некорректно считает например для FTC difficulty == 56
        # block_time = coin_data["difficulty"] / net_hash
        block_reward = float(self.block_reward)
        user_ratio = user_hashrate / float(net_hash)
        net_reward = period / block_time * block_reward
        user_reward = net_reward * user_ratio
        return user_reward


# make 2 tuple such ugly staff because of bug in model_form
PROFIT_CURRENCIES = (
    ('USD', 'USD'),
    ('EUR', 'EUR'),
    ('RUR', 'RUR'),
    ('BTC', 'BTC'),
    ('ETH', 'ETH'),
    ('ZEC', 'ZEC'),
)


class UserSettings(EmbeddedDocument):
    profit_currency = StringField(choices=PROFIT_CURRENCIES, default='RUR', required=True)
    default_configuration_group = ReferenceField('ConfigurationGroup') # NOT SUPPORTED: reverse_delete_rule=mongoengine.DENY
    auto_profit_switch_thresold = IntField(min_value=0, default=5, verbose_name="Profit threshold, %", help_text="threshold to switch better currency profit, %")


class User(Document):
    name = StringField()
    email = StringField(unique=True)
    api_key = StringField(unique=True, min_length=20, max_length=20)
    password = StringField(min_length=8)
    client_secret = StringField(required=True)
    target_currency = StringField()  # deprecated. user settings.profit_currency instead
    settings = EmbeddedDocumentField(UserSettings)

    def is_authenticated(self):
        return True

    def is_active(self):
        return True

    def is_anonymous(self):
        return False

    def get_id(self):
        return self.email

    def __unicode__(self):
        return self.name


class Pool(Document):
    name = StringField(max_length=100, uinque=True)
    user = ReferenceField(User, reverse_delete_rule=mongoengine.CASCADE)  # if exist then this is user's specific pool
    pool_family = StringField(max_length=30, choices=POOLS_FAMILY)
    info = StringField()
    website = URLField()
    currency = ReferenceField(Currency, required=True, reverse_delete_rule=mongoengine.DENY)
    fee = FloatField(required=True, default=0, min_value=0, max_value=1)  # fee rate. For 1% == 0.01
    servers = ListField(StringField(max_length=100, regex='[\w\.\-]+:\d+'))
    server = StringField(required=True, max_length=100, regex='[\w\.\-]+:\d+')  # server:port
    is_online = BooleanField(default=True)
    api_url = StringField()

    def __unicode__(self):
        return self.name


class MinerProgram(Document):
    name = StringField(max_length=200)  # human readable miner name
    code = StringField(max_length=100, unique=True)
    family = StringField(
        max_length=50)  # family has the same output handlers TODO: switch to miner_class + logger_name
    miner_class = StringField()  # class name of this miner program
    logger_name = StringField()  # logger from the client side using for this
    command_line = StringField(max_length=500)
    dir = StringField(max_length=200)
    win_exe = StringField(max_length=100)
    dir_linux = StringField(max_length=200)
    linux_bin = StringField(max_length=100)
    version = StringField()
    env = DictField(default={})
    # TODO: use String instead of List (because each algo has separate command line)
    # TODO: OR introduce Map 'algo' -> 'command'
    algos = ListField(StringField(),
                      required=True)  # supported algos (not only currencies but also duals like 'Ethash+pascal')
    supported_os = ListField(StringField(choices=OS_TYPE), required=True)
    supported_pu = ListField(StringField(choices=PU_TYPE), required=True)
    is_enabled = BooleanField(default=True)

    @queryset_manager
    def enabled(doc_cls, queryset):
        return queryset.filter(is_enabled=True)

    def __unicode__(self):
        return self.name


class Exchange(Document):
    name = StringField(max_length=50, unique=True)
    website = StringField(max_length=200)
    handler = StringField(max_length=200)  # subclass of Exchange

    def __unicode__(self):
        return self.name


class PoolAccount(Document):
    name = StringField(max_length=200)
    user = ReferenceField(User, reverse_delete_rule=mongoengine.CASCADE)
    pool = ReferenceField(Pool, required=True, reverse_delete_rule=mongoengine.DENY)
    #    currency = ReferenceField(Currency, required=True, verbose_name="Currency", radio=True)  # PERHAPS NOT NEED AS SOON AS POOL MINE ONLY ONE COIN
    login = StringField(required=True, max_length=200, help_text="Login for pool connection")
    password = StringField(max_length=100)
    is_active = BooleanField(default=True)

    def __unicode__(self):
        return "PoolAccount: {}, login=".format(self.server, self.pool_login)


class ConfigurationGroup(Document):
    name = StringField(max_length=100, required=True, verbose_name="Configuration Name")
    code = StringField(required=True, unique=True, verbose_name="Unique code")
    user = ReferenceField(User, reverse_delete_rule=mongoengine.CASCADE)
    miner_program = ReferenceField(MinerProgram, required=True, verbose_name="Miner", reverse_delete_rule=mongoengine.DENY)
    # algo: for single currency has taken from currency algo, for dual concatenate using '+'
    # example: 'Ethash', 'Ethash+Blake'
    algo = StringField(required=True)
    command_line = StringField()
    env = DictField(default={})
    currency = ReferenceField(Currency, required=True, verbose_name="Coin",
                              radio=True, reverse_delete_rule=mongoengine.DENY)  # PERHAPS NOT NEED AS SOON AS POOL MINE ONLY ONE COIN
    pool = ReferenceField(Pool, verbose_name="Pool", reverse_delete_rule=mongoengine.DENY)
    pool_server = StringField(required=True, max_length=100, regex='[\w\.\-]+:\d+',
                              verbose_name="Startum server")  # server:port
    pool_login = StringField(required=True, max_length=200, verbose_name="Pool login")
    pool_password = StringField(max_length=50, verbose_name="Pool password")
    exchange = ReferenceField(Exchange, reverse_delete_rule=mongoengine.DENY)
    wallet = StringField(max_length=200)
    is_dual = BooleanField(default=False)
    dual_currency = ReferenceField(Currency, verbose_name="Coin (dual)", reverse_delete_rule=mongoengine.DENY)
    dual_pool = ReferenceField(Pool, reverse_delete_rule=mongoengine.DENY)
    # so you thins regexp (...|) looks ugly? Complain to wtforms+mongoengine which trace '' as string value for field (instead of None)
    dual_pool_server = StringField(max_length=100, regex='([\w\.\-]+:\d+|)',
                                   verbose_name="Startum server (dual)")  # server:port
    dual_pool_login = StringField(max_length=200, verbose_name="Pool login")
    dual_pool_password = StringField(max_length=50, verbose_name="Pool password")
    dual_exchange = ReferenceField(Exchange, reverse_delete_rule=mongoengine.CASCADE)
    dual_wallet = StringField(max_length=200)
    is_active = BooleanField(default=True)

    @queryset_manager
    def list_for_user(doc_cls, queryset, user):
        return queryset.filter(is_active=True, user=user)

    @staticmethod
    def filter_applicable_for_rig(list, rig):
        result = []
        for configuration_group in list:
            if configuration_group.miner_program in rig.disabled_miner_programs:
                continue
            if not rig.pu in configuration_group.miner_program.supported_pu:
                continue
            if not rig.os in configuration_group.miner_program.supported_os:
                continue
            result.append(configuration_group)
        return result

    def __unicode__(self):
        return self.name

    def calc_profit_for_target_hashrate(self, target_hashrate):
        """
        :param target_hashrate:
        :return: profit value in BTC or None in case of exception.
        """
        try:
            profit = self.currency.calc_mining_profit(target_hashrate.hashrate)
            profit_btc = self.currency.get_median_btc_rate() * profit
            if self.is_dual:
                profit_dual = self.dual_currency.calc_mining_profit(target_hashrate.hashrate_dual)
                profit_btc += self.dual_currency.get_median_btc_rate() * profit_dual
            return profit_btc
        except:
            return None

class ExchangeRate(Document):
    exchange = ReferenceField(Exchange, unique_with=["from_currency", "to_currency"], reverse_delete_rule=mongoengine.CASCADE)
    from_currency = ReferenceField(Currency, reverse_delete_rule=mongoengine.DENY)
    to_currency = ReferenceField(Currency, reverse_delete_rule=mongoengine.DENY)
    rate = FloatField()
    when = DateTimeField()


class ExchangeRateHistory(Document):
    exchange = ReferenceField(Exchange, reverse_delete_rule=mongoengine.DENY)
    from_currency = ReferenceField(Currency, reverse_delete_rule=mongoengine.DENY)
    to_currency = ReferenceField(Currency, reverse_delete_rule=mongoengine.DENY)
    rate = FloatField()
    when = DateTimeField()


class Rig(Document):
    uuid = UUIDField(required=True, binary=False, unique=True)
    worker = StringField(regex='^[a-zA-Z0-9_]+$', max_length=50)
    configuration_group = ReferenceField(ConfigurationGroup, required=True, reverse_delete_rule=mongoengine.DENY)
    os = StringField(choices=OS_TYPE)
    pu = StringField(choices=PU_TYPE)
    user = ReferenceField(User, reverse_delete_rule=mongoengine.CASCADE)
    manager = StringField()  # required=True, default='AutoProfitRigManager', choices=MANAGERS,
    comment = StringField(max_length=100)
    system_gpu_list = ListField(StringField(), default=[])
    rebooted = DateTimeField()
    cards_temp = ListField(IntField(), default=list)
    cards_fan = ListField(IntField(), default=list)
    hashrate = DictField(default={})
    target_hashrate = DictField(
        default={})  # miner_code: { 'Ethash+Blake': { 'Ethash': 23, 'Blake': 4456 },}, miner_code: { 'Ethash': { 'Ethash': 25 }
    is_online = BooleanField(default=False)
    last_online_at = DateTimeField()
    is_miner_run = BooleanField(default=False)
    log_to_file = BooleanField(defaul=False)  # TODO: implement filter in logging_server. Now logs all
#    disabled_algos = ListField(StringField(choices=[('a','a'),('b','b')]), default=[])
    disabled_miner_programs = ListField(ReferenceField(MinerProgram, reverse_delete_rule=mongoengine.CASCADE), verbose_name="Disabled Miners", help_text="You may turn off some miners from running on this rig")

    def __unicode__(self):
        return "rig '{}' (uuid={})".format(self.worker, self.uuid)

    def __eq__(self, other):
        return self.uuid.__eq__(other.uuid)

    def get_current_profit_btc(self):
        """
        calculate current profit for given rig. Convert profit to given currency.
        :param self:
        :return: value of profit
        """
        currency = self.configuration_group.currency
        profit_btc = 0
        if currency.algo in self.hashrate:
            profit = currency.calc_mining_profit(self.hashrate[currency.algo])
            profit_btc = currency.get_median_btc_rate() * profit
        dual_profit_btc = 0
        if self.configuration_group.is_dual:
            dual_currency = self.configuration_group.dual_currency
            if dual_currency.algo in self.hashrate:
                dual_profit = currency.calc_mining_profit(self.hashrate[currency.algo])
                dual_profit_btc = currency.get_median_btc_rate() * dual_profit
        return profit_btc + dual_profit_btc


class TargetHashrate(Document):
    rig = ReferenceField(Rig, required=True, unique_with=['miner_program', 'algo'], reverse_delete_rule=mongoengine.CASCADE)
    miner_program = ReferenceField(MinerProgram, required=True, reverse_delete_rule=mongoengine.CASCADE)
    algo = StringField(required=True)
    algorithm = StringField(required=True)
    hashrate = FloatField(default=0)
    algorithm_dual = StringField()
    hashrate_dual = FloatField(default=0)

