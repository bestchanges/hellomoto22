import json
import logging
from threading import Thread
from urllib.request import Request, urlopen
import time

from exchange.exchange import PoloniexExchange, BitfinexExchange
from models import Currency, Rig

logger = logging.getLogger(__name__)


def calc_mining_profit(currency, user_hashrate, period=86400):
    '''
    * считаем сколько монет за определенное время можем получить на данном оборудовании
    N = (t*R*H)/(D*2^32)
    где:
    N - доход в монетах
    t - период майнинга в секундах (например, сутки = 86400)
    R - награда за блок в монетах
    H - хэшрейт в секунду (например, 1ГХш = 1000000000)
    D - сложность

    доход в сутки = ( мощность фермы / мощность сети ) Х кол-во монет в сутки
    кол-во монет в сутки  = ( 86400 Х монет за блок ) / время нахождения блока

    :param coin_data: the data generated by for_currency("ETH")
    :param hashrate:
    :param period:
    :return: amount of currency earned during period
    '''
    if not currency.nethash:
        raise Exception("currency {} has no nethash".format(currency))
    if not currency.block_time:
        raise Exception("currency {} has no block_time".format(currency))
    net_hash = currency.nethash
    block_time = float(currency.block_time)
    # некорректно считает например для FTC difficulty == 56
    # block_time = coin_data["difficulty"] / net_hash
    block_reward = float(currency.block_reward)
    user_ratio = user_hashrate / float(net_hash)
    net_reward = period / block_time * block_reward
    user_reward = net_reward * user_ratio
    return user_reward

class ProfitManager(Thread):

    def evaluate_rig(self, rig):
        exchanges = [
            BitfinexExchange(),
            PoloniexExchange(),
        ]

        best_algos = {}
        for algo, hashrate_data in rig.target_hashrate.items():
            algo_profit_btc = 0
            bests = []
            for algorithm in algo.split('+'):
                hashrate_value = hashrate_data[algorithm]
                logger.info("{} {} {}".format(algo, algorithm, hashrate_value))
                currencies = Currency.objects(algo=algorithm)
                logger.info(currencies)
                max_profit_currency = {'a': algorithm, 'max': 0, 'c': None, 'e': None}
                for currency in currencies:
                    try:
                        profit = calc_mining_profit(currency, hashrate_value)
                        # try to convert on exchanges
                        profit_btc = 0
                        exchange_code = None
                        best_exchange = { 'e': None, 'rate': 0}
                        for exchange in exchanges:
                            try:
                                rate = exchange.exchange_rate(currency.code, 'BTC')
                                if rate:
                                    if rate > best_exchange['rate']:
                                        best_exchange = { 'e': exchange.code, 'rate': rate }
                            except Exception as e:
                                logger.warning("error converting {} in {}: {}".format(currency, exchange, e))
                                continue
                        profit_btc = best_exchange['rate'] * profit
                        if profit_btc > max_profit_currency['max']:
                            max_profit_currency = {'a': algorithm, 'c': currency.code, 'max': profit_btc, 'e': best_exchange}
                        logger.info("{} = {} ({} BTC)".format(currency.code, profit, profit_btc))
                    except Exception as e:
                        logger.error(e)
                        raise e
                bests.append(max_profit_currency)
                logger.warning("Algorithm {} Best currency {} = {} BTC (at {})".format(algorithm, max_profit_currency['c'], max_profit_currency['max'], max_profit_currency['e']))
                algo_profit_btc = algo_profit_btc + max_profit_currency['max']
            logger.error("Algo {} = {} BTC".format(algo, algo_profit_btc))
            best_algos[algo] = { 'profit': algo_profit_btc, 'c': bests }
        print(json.dumps(best_algos, indent=2, sort_keys=True))


    def load_data_from_whattomine(self):
        logger.info("Loading currencies data from WhatToMine")
        try:
            q = Request('http://whattomine.com/coins.json')
            q.add_header('User-agent',
                         'Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5')
            a = urlopen(q)
            response = a.read().decode('utf-8')
            result = json.loads(response)
            # save latest data to file
            if len(result) > 0:
                fout = open('coins.json', 'w')
                json.dump(result, fout, indent=2, sort_keys=True)
            return result
        except Exception as e:
            logging.error("Error loading currencies: {} ".format(e))

    def update_currency_data_from_whattomine(self, wtm):
        '''
        :param wtm: What To Mine JSON decoded
        :return:
        '''
        logger.info("Update currency data {} items.".format(len(wtm['coins'].items())))
        for currency, data in wtm['coins'].items():
            Currency.objects(
                code=data['tag'],
            ).update_one(
                algo=data["algorithm"],
                block_reward=data["block_reward"],
                block_time=data["block_time"],
                difficulty=data["difficulty"],
                nethash=data["nethash"],
                upsert=True
            )

    def run(self):
        # update once from file
        self.update_currency_data_from_whattomine(json.load(open('coins.json')))

        # False = disable periodical load
        while False:
            self.update_currency_data_from_whattomine(self.load_data_from_whattomine())
            time.sleep(300)


pm = ProfitManager()

if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO)
    #data = pm.load_data_from_whattomine()
    data = json.load(open('coins.json'))
    pm.update_currency_data_from_whattomine(data)
    rig = Rig.objects.get(worker="worker002")
    pm.evaluate_rig(rig)
